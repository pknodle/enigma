package enigma

//import enigma.EnigmaUtil
//import enigma.Rotor

// This creates an mapping for an Enigma rotor.
// The string is a specially formatted array which represents the mapping encoded by this wheel.
//
// The array is encoded so that the element encodes the output that resutls from putting
// a signal on the first pin of the rotor.  
//

class Rotor(mapping: Array[Int], advancementPointsArg :List[Int]) {

  var advancementPoints = advancementPointsArg

  def encode(input : Int, rotorPosition : Int) = {
    // This encodes an input 
    mapping( (input + rotorPosition) % 26)
  }

  def getReflection = {
    // This returns an enima wheel that models the reflection of this one.
    // Remember that the Enimga machine works by connection an input signal
    // (generated by the keyboard of the machine) through the the the first three rotors.
    // Then is sends the the input through a reflector rotor and then back through the three
    // rotors.
    //
    // This generates a rotor that is the inverse of this rotor that can be used in the
    // reflection operation.
    //
    //
    var reflectionCoding = new Array[Int](26)
    List.range(0,26).foreach(i => reflectionCoding(mapping(i)) = i)
  }

  def this(mappingString : String, advancementPointsArg: List[Int])  {
    this ({
      var index = 0
      var coding = new Array[Int](26)
      List.range(0,26).foreach(i => coding(i) = EnigmaUtil.positionInAlphabet(mappingString(i)))
      coding
    }, advancementPointsArg)


  }



}

